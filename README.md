rasen
================

[![crates.io](https://img.shields.io/crates/v/rasen.svg)](https://crates.io/crates/rasen/)
[![AppVeyor Status](https://ci.appveyor.com/api/projects/status/github/leops/rasen?svg=true)](https://ci.appveyor.com/project/leops/rasen)
[![Travis Status](https://travis-ci.org/leops/rasen.svg?branch=master)](https://travis-ci.org/leops/rasen/)

Rasen aims at providing a fast and safe compiler for SPIR-V modules from a "dataflow graph". Such a graph is a usually a
metadata generated by a compiler, but proved to be a very useful tool for quickly prototyping shader (as seen in
node-based materials editors like Unreal's).

# Core
The `rasen` crate contains the core graph compiler itself. It provides graph building utilities (the `Graph` struct),
various types (`rasen::types::*`) and operations (`rasen::node::*`) definitions, and SPIR-V compilation utilities (the
`Builder` struct).

It's perfectly possible to use this crate as-is by creating a `Graph` struct and buidling the module node-by-node,
though this method tends to be quite verbose:
```rust
extern crate rasen;

use rasen::prelude::*;

fn main() {
    let mut graph = Graph::new();

    // A vec3 input at location 0
    let normal = graph.add_node(Node::Input(0, TypeName::Vec(3)));

    // Some ambient light constants
    let min_light = graph.add_node(Node::Constant(TypedValue::Float(0.1)));
    let max_light = graph.add_node(Node::Constant(TypedValue::Float(1.0)));
    let light_dir = graph.add_node(Node::Constant(TypedValue::Vec3(0.3, -0.5, 0.2)));

    // The Material color (also a constant)
    let mat_color = graph.add_node(Node::Constant(TypedValue::Vec4(0.25, 0.625, 1.0, 1.0)));

    // Some usual function calls
    let normalize = graph.add_node(Node::Normalize);
    let dot = graph.add_node(Node::Dot);
    let clamp = graph.add_node(Node::Clamp);
    let multiply = graph.add_node(Node::Multiply);

    // And a vec4 output at location 0
    let color = graph.add_node(Node::Output(0, TypeName::Vec(4)));

    // Normalize the normal
    graph.add_edge(normal, normalize, 0);

    // Compute the dot product of the surface normal and the light direction
    graph.add_edge(normalize, dot, 0);
    graph.add_edge(light_dir, dot, 1);

    // Restrict the result into the ambient light range
    graph.add_edge(dot, clamp, 0);
    graph.add_edge(min_light, clamp, 1);
    graph.add_edge(max_light, clamp, 2);

    // Multiply the light intensity by the surface color
    graph.add_edge(clamp, multiply, 0);
    graph.add_edge(mat_color, multiply, 1);

    // Write the result to the output
    graph.add_edge(multiply, color, 0);

    let bytecode = build_program(&graph, ShaderType::Fragment).unwrap();
    // bytecode is now a Vec<u8> you can pass to Vulkan to create the shader module
}
```

# DSL
To reduce the amount of boilerplate, the `rasen_dsl` crate provides a bunch of utility function to write shaders as
perfectly valid Rust code:
```rust
extern crate rasen;
extern crate rasen_dsl;

use rasen_dsl::prelude::*;

fn main() {
    let shader = Shader::new();

    let normal: Value<Vec3> = normalize(shader.input(0));
    let light = vec3(0.3, -0.5, 0.2);
    let color = vec4(0.25, 0.625, 1.0, 1.0);

    let res = clamp(dot(normal, light), 0.1f32, 1.0f32) * color;
    shader.output(0, res);

    let bytecode = shader.build(ShaderType::Fragment).unwrap();
    // bytecode is now a Vec<u8> you can pass to Vulkan to create the shader module
}
```

This crate is even more experimental than the Rasen compiler itself but it already provides all the features exposed by
the compiler.

Ultimately, the goal for the DSL crate (beside being a statically-checked equivalent of the graph builder) is to expose
an API to test the execution of a shader on the CPU, with all the debugging tools that such an environment provides. The
library currently provides all the conversion primitives to turn your scalar / vectors / matrices into Value<_> types to
test your program, however most GLSL operations are left unimplemented.

# Plugin
Finally, the `rasen_plugin` crate is a compiler plugin exposing a few utility macro and attributes to make writing
shaders in Rust event easier:
```rust
use rasen_dsl::prelude::*;

#[shader]
pub fn basic_vert(a_pos: Value<Vec3>, projection: Value<Mat4>, view: Value<Mat4>, model: Value<Mat4>) -> Value<Vec4> {
   let mvp = projection * view * model;
   mvp * vec4!(a_pos, 1.0f32)
}
```
